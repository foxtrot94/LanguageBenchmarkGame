#!/usr/bin/env python

output_file_name = 'program.out'

preferred_compiler = 'clang' # or g++, up to you

argtable_download_url = 'https://github.com/argtable/argtable3/releases/download/v3.1.2.bb37058/argtable-3.1.2-amalgamation.zip'

def setup():
    import os, datetime, subprocess, sys
    if os.path.exists(os.path.join(os.getcwd(), "setup.log")):
        print("'setup.log' exists. C implementation setup correctly")
        return

    # We can't really setup this successfully, we need a build system like CMake or scons for xplat support
    # print("Requires libboost-filesystem-dev libcrypto++-dev libcrypto++9v5")
    try:
        with open('setup.log', 'w') as logFile:
            logFile.write("# This is an autogenerated file made by 'run.py' on {}\n".format(datetime.datetime.now()))
            logFile.write("# => DO NOT DELETE THIS FILE OR SETUP WILL BE CALLED AGAIN\n")
            logFile.flush()

            # Check the preferred compiler version
            subprocess.run([preferred_compiler, "-v"], stdout = logFile, stderr = logFile, check=True)

            # Download 'argtable' dependency
            old_stdout = sys.stdout
            sys.stdout = logFile
            logFile.flush()

            import urllib.request
            print("Downloading 'argtable' from {}".format(argtable_download_url))
            argtable_download, headers = urllib.request.urlretrieve(argtable_download_url)

            from zipfile import ZipFile
            with ZipFile(argtable_download) as argtable_zip:
                print("Extracting 'argtable' download")
                argtable_zip.extractall()

            unzip_dir = os.path.split(os.path.splitext(argtable_download_url)[0])[-1]
            print("Successfully extracted to '{}'".format(unzip_dir))
            os.rename(unzip_dir , 'argtable')
            print("'{}' -> 'argtable'".format(unzip_dir))

            sys.stdout = old_stdout
            logFile.flush()

            # init the submodule we need
            subprocess.run(['git', 'submodule','update', '--init', '--', 'klib'], stdout = logFile, stderr = logFile, check=True)
            logFile.write("\n# Setup completed on {}".format(datetime.datetime.now()))
        #end logFile
    except Exception as e:
        print(e)
        if os.path.exists('setup.log'):
            os.remove('setup.log')
#end run

def build():
    import subprocess, os

    # remove the previous build
    if os.path.exists(output_file_name):
        os.remove(output_file_name)

    source_files = [x for x in os.listdir('.') if x.endswith('.c')] + [os.path.join('argtable', 'argtable3.c')]
    c_libs = ['-lm']
    c_defs = ['-DNDEBUG']

    # For older versions of clang++/g++, the order of the source files matters!
    process_args = [preferred_compiler] + source_files + ['-Wall', '-pedantic',  '-Ofast', '-o', output_file_name] + c_libs + c_defs
    subprocess.call(process_args)

    if os.path.exists(output_file_name):
        print("Built C implementation as '{}'".format(output_file_name))
    else:
        raise AssertionError("Build failed")
#end run

def run(cmd_args):
    import subprocess
    process_args = ["./{}".format(output_file_name)] + cmd_args
    retcode = subprocess.call(process_args)
    if retcode != 0:
        raise RuntimeError("Program run returned non-zero exit code")
#end run

if __name__=="__main__":
    import sys, os

    setup()
    build()
    if os.path.basename(sys.argv[0]) == os.path.basename(__file__):
        run(sys.argv[1:])
# end main
        
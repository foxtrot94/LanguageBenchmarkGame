#!/usr/bin/env python

import os, platform

is_windows = os.name == 'nt'

build_platform_map = \
    {
    'Linux' : { 'x86_64': 'linux-x64', 'armv7l': 'linux-arm', 'aarch64': 'linux-arm64' },
    'Darwin': { 'x86_64': 'osx-x64' },
    'Windows': { 'x86_64': 'win-x64' }
    }

build_platform = build_platform_map[platform.system()][platform.machine()]

output_file_name = os.path.join('bin','Release','netcoreapp2.1',build_platform, 'csharp')
if is_windows:
    output_file_name += ".exe"

def setup():
    import os, subprocess, datetime
    if os.path.exists(os.path.join(os.getcwd(), "setup.log")):
        print("'setup.log' exists. C# implementation setup correctly")
        return

    # We can't really setup this successfully, we need a build system like CMake or scons for xplat support
    print("Watch for Errors - Requires dotnet-sdk manually and have 'dotnet' as a command")
    try:
        with open('setup.log', 'w') as logFile:
            logFile.write("# This is an autogenerated file made by 'run.py' on {}\n".format(datetime.datetime.now()))
            logFile.write("# => DO NOT DELETE THIS FILE OR SETUP WILL BE CALLED AGAIN\n")

            logFile.flush()
            subprocess.run(['dotnet', '--info'], stdout = logFile, stderr = logFile, check=True)
            subprocess.run(["dotnet", "restore"], stdout = logFile, stderr = logFile, check=True)
            logFile.flush()

            logFile.write("\n# Setup completed on {}".format(datetime.datetime.now()))
        #end logFile
    except Exception as e:
        print(e)
        if os.path.exists('setup.log'):
            os.remove('setup.log')
#end run

def build():
    import subprocess

    subprocess.call(['dotnet', 'restore'])
    retcode = subprocess.call(['dotnet', 'build', '-c', 'Release', '-r', build_platform])

    if retcode == 0 and os.path.exists(output_file_name):
        print("Built C# implementation as '{}'".format(output_file_name))
    else:
        raise AssertionError("Build failed")
#end run

def run(cmd_args):
    import subprocess
    process_args = ['./{}'.format(output_file_name)] + cmd_args
    retcode = subprocess.call(process_args)
    if retcode != 0:
        raise RuntimeError("Program run returned non-zero exit code")
#end run

if __name__=="__main__":
    import sys

    setup()
    build()
    if os.path.basename(sys.argv[0]) == os.path.basename(__file__):
        run(sys.argv[1:])
# end main
        
